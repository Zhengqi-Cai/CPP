#pragma once
///////////////////////////////////////////////////////////////////////
// CodeUtilities.h - small, generally useful, helper classes         //
// ver 1.3                                                           //
// Language:    C++, Visual Studio 2017                              //
// Application: Most Projects, CSE687 - Object Oriented Design       //
// Author:      Ammar Salmon, TA, CSE687                             //
// Source:      Jim Fawcett, Syracuse University, CST 4-187          //
//              jfawcett@twcny.rr.com                                //
///////////////////////////////////////////////////////////////////////
/*
* Package Operations:
* -------------------
* This package provides classes:
* - ProcessCmdLine    extracts path, options, patterns, and a number from command line
* - Converter<T>      converts T to and from strings
* - Box<T>            converts primitive type to instance of a class
* - PersistFactory<T> adds toXml() method to T
*
* Build Process:
* --------------
* Required Files:
*   CodeUtilities.h
*
* Maintenance History:
* --------------------
* ver 1.3 : 16 Aug 2018
* - added default usage text
* ver 1.2 : 11 Aug 2018
* - added ProcessCmdLine::hasOption method
* - fixed bugs in ProcessCmdLine::showCmdLine
*   and ProcessCmdLine::showOptions
* ver 1.1 : 10 Aug 2018
* - added ProcessCmdLine class
* ver 1.0 : 12 Jan 2018
* - first release
* - refactored from earlier Utilities.h
*
* Notes:
* ------
* - Designed to provide all functionality in header file.
* - Implementation file only needed for test and demo.
*
* Planned Additions and Changes:
* ------------------------------
* - none yet
*/

#include <vector>
#include <string>
#include <sstream>
#include <iostream>
#include <regex>

namespace Utilities
{
	void preface(bool logOpen, const std::string& msg = "", bool doReturn = true, const std::string& prefix = "  ");

	std::string defaultUsage();

	/////////////////////////////////////////////////////////////////////
	// ProcessCmdLine class
	// - extracts path, patterns, options, number

	class ProcessCmdLine
	{
	public:
		using Usage = std::string;
		using Path = std::string;
		using Option = int;
		using Options = std::vector<Option>;
		using Pattern = std::string;
		using Patterns = std::vector<Pattern>;
		using Regexes = std::vector<std::string>;
		using Number = long int;

		ProcessCmdLine(int argc, char** argv);
		ProcessCmdLine(const ProcessCmdLine&) = delete;
		ProcessCmdLine& operator=(const ProcessCmdLine&) = delete;

		bool parseError();
		Path path();
		void path(const Path& path);
		Options options();
		void option(Option op);
		bool hasOption(Option op);
		Patterns patterns();
		Regexes regexes();
		void pattern(const Pattern& patt);
		Number maxItems();
		void maxItems(Number number);
		void usage(const Usage& usage);
		void usage();
		//void showCmdLine(int argc, char** argv);
		void showCmdLine();
		void showPath();
		void showOptions();
		void showPatterns();
		void showRegexes();
		void showMaxItems();

	private:
		bool isValidRegex(const std::string& regex);
	private:
		Usage usage_;
		Path path_;
		Patterns patterns_;
		Regexes regexes_;
		Options options_;
		int maxItems_ = 0;
		bool parseError_ = false;
		bool logOpen_=true;
	};

	

	/////////////////////////////////////////////////////////////////////
	// Converter class
	// - supports converting unspecified types to and from strings
	// - a type is convertible if it provides insertion and extraction
	//   operators

	template <typename T>
	class Converter
	{
	public:
		static std::string toString(const T& t);
		static T toValue(const std::string& src);
	};
	//----< convert t to a string >--------------------------------------

	template <typename T>
	std::string Converter<T>::toString(const T& t)
	{
		std::ostringstream out;
		out << t;
		return out.str();
	}
	//----< convert a string to an instance of T >-----------------------
	/*
	*  - the string must have been generated by Converter<T>::toString(const T& t)
	*  - T::operator>> must be the inverse of T::operator<<
	*/
	template<typename T>
	T Converter<T>::toValue(const std::string& src)
	{
		std::istringstream in(src);
		T t;
		in >> t;
		return t;
	}

	///////////////////////////////////////////////////////////////////////
	// Box class
	// - wraps primitive type in class
	// - preserves primitive syntax

	template<typename T>
	class Box
	{
	public:
		Box() : primitive_(T()) {}
		Box(const T& t) : primitive_(t) {}
		operator T&() { return primitive_; }
		T& operator=(const T& t) { primitive_ = t; return primitive_; }
	private:
		T primitive_;
	};

	///////////////////////////////////////////////////////////////////////
	// ToXml interface
	// - defines language for creating XML elements

	struct ToXml
	{
		virtual std::string toXml(const std::string& tag) = 0;
		virtual ~ToXml() {};
	};

	///////////////////////////////////////////////////////////////////////
	// PersistFactory<T> class
	// - wraps an instance of user-defined type
	// - preserves semantics of user-defined type
	// - adds toXml("tag") method

	template<typename T>
	class PersistFactory : public T, ToXml
	{
	public:
		PersistFactory() = default;
		PersistFactory(const T& t)
		{
			T::operator=(t);
		}
		std::string toXml(const std::string& tag)
		{
			std::ostringstream out;
			out << "<" << tag << ">" << *this << "</" << tag << ">";
			return out.str();
		}
	};
}